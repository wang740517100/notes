1、谈谈你对Java平台的理解。

面向对象（封装，继承，多态）
平台无关性（JVM运行.class文件）
语言（泛型，Lambda）
类库（集合，并发，网络，IO/NIO）
JRE（Java运行环境，JVM，类库）
JDK（Java开发工具，包括JRE，javac，诊断工具）
垃圾回收、类加载过程和机制


JIT(即时编译器)能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行。
JIT是一种提高程序运行效率的方法。通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而动态解释执行的则是一句一句边运行边翻译。


封装也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
继承是指可以让某个类型的对象获得另一个类型的对象的属性或方法。它支持按级分类的概念。
多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。


2、Error和Exception的区别。
- 代码要捕捉特定的异常，不要去捕捉uncheck execption
- 不要生吞异常

3、final、finally和finalize的区别。
扩展: Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻象引用
（PhantomReference），这是一种常见的所谓 post-mortem 清理机制。我会在后面的专栏系统介绍 Java 的各种引用，利用
幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的资源），
它比 finalize 更加轻量、更加可靠。


4、动态代理的原理是什么。
动态代理就是代理实体对象替代被代理对象去执行动作，让调用者与实现者之间解耦，并且在动作前后添加一些特有动作的一个设计模式。
它常见的实现有jdk自带动态代理和cglib，实现的原理是反射。
- jdk自带动态代理是使用反射调用被代理对象增加动作
- cglib是使用反射生成子类重写被代理对象方法
JDK Proxy 比 cglib 或者 Javassist 慢几十倍

反射机制是 Java 语言提供的赋予程序在运行时直接操作类或者对象的机制。比如获取某个对象的类定义，获取类声明的属性和
方法，调用方法或者构造对象，甚至可以运行时修改类定义。


5、 int和Integer有什么区别。
Integer 是 int 对应的包装类，在 Java 5 中，引入了自动装箱拆箱功能（boxing/unboxing），Java 可以根据上下文
自动进行转换，极大地简化了相关编程。
- 自动装箱(int -> Integer)  Integer.valueOf()
- 自动拆箱(Integer -> int)  Integer.intValue()
自动装箱拆箱机制只是一个语法糖, 只能发生在编译器编译阶段。

构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象，但是在 Java 5 中新增了静态工厂方法 valueOf，
在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间

建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销可不是一个
数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。

6、String、StringBuilder、StringBuffer的区别。
- String类用final修饰的，对象不可变，a = "a" + "b" 时在创建新的对象，String在堆里有常量池。
- StringBuilder是线程不安全的
- StringBuffer的区别是线程安全的，锁粗化


7、 谈谈接口和抽象类有什么区别。
接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。接口，不能实例化；
不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，
也就是说要么是抽象方法，要么是静态方法。Java 标准类库中，定义了非常多的接口，比如 java.util.List。
- 从 Java 8 开始，interface 增加了对 default method 的支持。
- Java 9 以后，甚至可以定义 private default method。

抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的
Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用
方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java 标准库中，比如 collection 框架，很多
通用部分就被抽取成为抽象类，例如 java.util.AbstractList。

