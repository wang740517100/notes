架构设计的关键思维是判断和取舍，程序设计的关键思维是逻辑和实现


读写分离: 解决读写的性能瓶颈
主从集群：“从机”是需要提供读数据的功能的。eg: mysql、elasticsearch
主备集群：“备机”被认为仅仅提供备份功能，不提供访问功能。 eg: redis

主从集群的问题: 主从复制延迟和分配机制
主从复制延迟解决方案:
- 写操作后的读操作指定发给数据库主服务器, 业务强绑定容易写bug
- 二次读取, 读从机失败后再读一次主机, 有很多二次读取时增加主机的读操作压力(网络攻击)
- 关键业务读写操作全部指向主机，非关键业务采用读写分离

分配机制解决方案:  访问不同的数据库服务器一般有：程序代码封装和中间件封装。
程序代码封装:
- 实现简单，而且可以根据业务做较多定制化的功能。
- 每个编程语言都需要自己实现一次，无法通用，如果一个业务包含多个编程语言写的多个子系统，则重复开发的工作量比较大。
- 故障情况下，如果主从发生切换，则可能需要所有系统都修改配置并重启
eg: TDDL（Taobao Distributed Data Layer，外号: 头都大了）
通用数据访问层, 基于集中式配置的 jdbc datasource 实现，具有主备、读写分离、动态数据库配置等功能

中间件封装:
- 能够支持多种编程语言，因为数据库中间件对业务服务器提供的是标准 SQL 接口
- 数据库中间件要支持完整的 SQL 语法和数据库服务器的协议（例如，MySQL 客户端和服务器的连接协议），
  实现比较复杂，细节特别多，很容易出现 bug，需要较长的时间才能稳定。
- 数据库中间件自己不执行真正的读写操作，但所有的数据库操作请求都要经过中间件，中间件的性能要求也很高
eg: MySQL Router MySQL Router 的主要功能有读写分离、故障自动切换、负载均衡、连接池等
    奇虎 360 公司也开源了自己的数据库中间件 Atlas，Atlas 是基于 MySQL Proxy 实现的


分库分表: 解决存储压力瓶颈
- 数据量太大，读写的性能会下降，即使有索引，索引也会变得很大，性能同样会下降。
- 数据文件会变得很大，数据库备份和恢复需要耗费很长时间。
- 数据文件越大，极端情况下丢失数据的风险越高（例如，机房火灾导致数据库主备机都发生故障）。

业务分库: 业务分库指的是按照业务模块将不同业务数据分散到不同的数据库服务器，比如用户表和订单表
- join 操作问题, 无法使用join使操作变得复杂
- 事务问题, 同库中简单的事务变成分布式事务
- 成本问题, 业务分库同时也带来了成本的代价

分表：同一业务的单表数据也会达到单台数据库服务器的处理瓶颈
- 垂直分表：垂直分表适合将表中某些不常用且占了大量空间的列拆分出去，可以带来一定的性能提升
- 水平分表：水平分表适合表行数特别大的表
水平分表路由算法：
- 范围路由：范围路由的优点是可以随着数据的增加平滑地扩充新的表，缺点是分布不均匀
- Hash 路由：初始表数量的选取上，表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。
  而用了 Hash 路由后，增加字表数量是非常麻烦的，所有数据都要重分布。
- 配置路由：配置路由就是路由表，用一张独立的表来记录路由信息。同样以用户 ID 为例，我们新增一张
  user_router 表，这个表包含 user_id 和 table_id 两列，根据 user_id 就可以查询对应的 table_id。
  配置路由的缺点就是必须多查询一次，会影响整体性能；而且路由表本身如果太大（例如，几亿条数据），
  性能同样可能成为瓶颈，如果我们再次将路由表分库分表，则又面临一个死循环式的路由算法选择问题。

分表带来的问题：
- join 操作：数据分散在多个表中，需要中间件多次join或者在业务层相加
- count() 操作: 1)count() 相加, 简单，如果有20张表串行读性能低; 2)新建一张表，假如表名为“记录数表”，
  包含 table_name、row_count 两个字段，每次插入或者删除子表数据成功后，都更新“记录数表”, 性能好但
  复杂度增高很多。
- order by 操作：水平分表后，数据分散到多个子表中，排序操作无法在数据库中完成，只能由业务代码或者数据
  库中间件分别查询每个子表中的数据，然后汇总进行排序

和数据库读写分离类似，分库分表具体的实现方式也是“程序代码封装”和“中间件封装”，但实现会更复杂。读写分离
实现时只要识别 SQL 操作是读操作还是写操作，通过简单的判断 SELECT、UPDATE、INSERT、DELETE 几个关键字
就可以做到，而分库分表的实现除了要判断操作类型外，还要判断 SQL 中具体需要操作的表、操作函数（例如 count
 函数)、order by、group by 操作等，然后再根据不同的操作进行不同的处理。例如 order by 操作，需要先从多
 个库查询到各个库的数据，然后再重新 order by 才能得到最终的结果。