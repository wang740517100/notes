----------------------------------  zookeeper有哪些使用场景 ----------------------------------
1)分布式协调。mq的强一致性
服务a感知服务b的操作, 完成消息通信。
创建 -> 更新 -> 查询节点是否更新

2)分布式锁。
创建 -> 删除节点

3)元数据/配置信息管理。rpc框架
注册中心/配置中心

4)HA高可用性。大数据框架
备用服务a感知服务b宕机后自动切换线路
临时节点(机器挂了节点就被删除了)

---------------------------------- 分布式session ----------------------------------
session和cookie的区别

1)tomcat + redis
tomcat配置文件里配置redisSessionManager的信息
严重依赖于web容器(tomcat), 要是移植web容器怎么办

2)spring session + redis
拦截器

3)自研: 基于es自己搭建

----------------------------------  分布式事务方案 ----------------------------------
1)两阶段提交: spring + jta
微服务不允许连别服务的库，一般都没有使用场景

2)tcc方案:
在catch里面补偿,会增加业务复杂度
一般在强一致性系统使用，一般和钱相关的系统使用。
增加服务订单，取消服务订单

3)本地消息表: mysql消息表
mq或者zk分布式协调

4)可靠消息: 最终一致性
a发消息b，如果b失败a重试

5)最大努力通知方案
记录日志

6)一般都是告警 + 手动补偿


----------------------------------  如何设计一个高并发的系统 ----------------------------------
1)mysql扛一两千
2)redis分担查询压力   几万
3)mq削峰分担写压力    几万
4)分库分表，读写分离
5)es 承担查询压力

6)需要实际的分布式经验

6、分库分表。
分库分表主要为了扛写高并发
分布分表中间件是为了做hash分发

数据库中间件: 1)proxy  2)jar包和服务部署一起
sharding jdbc  升级时所有服务都要升级，耦合太强
mycat          独立运维，需要运维成本

数据库怎么拆分:
垂直拆分: 拆字段    金融订单多表
水平拆分: 拆条数    就是分库分表

根据id hash、 扛压好，扩容男
根据时间 hash  抗压低，扩容易

怎么迁移分库分表：
1、停机迁移数据
2、上线分库分表，将数据双写两个数据源，写一个程序同步老数据源的数据，监听老数据的变化。


----------------------------------  如何设计高可用的分布式系统 ----------------------------------
hystrix：限流、降级、熔断、隔离

----------------------------------  分布式ID怎么实现 ----------------------------------
分布式ID需要满足那些条件：
全局唯一：必须保证ID是全局性唯一的，基本要求
高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈
高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性
好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单
趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求

UUID
优点：
1）生成足够简单，本地生成无网络消耗，具有唯一性
缺点：
1）无序的字符串，不具备趋势自增特性
2）没有具体的业务含义
3）长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，
作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。


数据库自增ID：
CREATE DATABASE `SEQ_ID`;
CREATE TABLE SEQID.SEQUENCE_ID (
    id bigint(20) unsigned NOT NULL auto_increment,
    value char(10) NOT NULL default '',
    PRIMARY KEY (id),
) ENGINE=MyISAM;
insert into SEQUENCE_ID(value)  VALUES ('values');
优点：实现简单，ID单调自增，数值类型查询速度快
缺点：DB单点存在宕机风险，无法扛住高并发场景


数据库多主模式：
前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，
也就是两个Mysql实例都能单独的生产自增ID。那这样还会有个问题，两个MySQL实例的自增ID都从1开始，会生成重复的ID怎么办？
解决方案：设置起始值和自增步长
MySQL_1 配置：
set @@auto_increment_offset = 1;     -- 起始值
set @@auto_increment_increment = 2;  -- 步长
MySQL_2 配置：
set @@auto_increment_offset = 2;     -- 起始值
set @@auto_increment_increment = 2;  -- 步长
优点：解决DB单点问题
缺点：不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。


号段模式：
号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，
例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：
CREATE TABLE id_generator (
  id int(10) NOT NULL,
  max_id bigint(20) NOT NULL COMMENT '当前最大id',
  step int(20) NOT NULL COMMENT '号段的布长',
  biz_type    int(20) NOT NULL COMMENT '业务类型',
  version int(20) NOT NULL COMMENT '版本号',
  PRIMARY KEY (`id`)
)
等这批号段ID用完，再次向数据库申请新号段，对max_id字段做一次update操作，update max_id= max_id + step，update成功则说明新号段获取成功，
新的号段范围是(max_id ,max_id +step]。update id_generator set max_id = #{max_id+step}, version = version + 1 where version = # {version} and biz_type = XXX
由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。


Redis实现：
Redis也同样可以实现，原理就是利用redis的 incr命令实现ID的原子性自增。
127.0.0.1:6379> set seq_id 1     // 初始化自增ID为1
OK
127.0.0.1:6379> incr seq_id      // 增加1，并返回递增后的数值
(integer) 2
用redis实现需要注意一点，要考虑到redis持久化的问题。redis有两种持久化方式RDB和AOF

雪花算法（SnowFlake）：
雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。
Snowflake生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。
Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。
第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。
时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，
(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年
工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。
序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID
根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用
有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用


滴滴出品（TinyID）
Tinyid由滴滴开发，Github地址：https://github.com/didi/tinyid。

百度 （Uidgenerator）
uid-generator是由百度技术部开发，项目GitHub地址 https://github.com/baidu/uid-generator
uid-generator是基于Snowflake算法实现的，与原始的snowflake算法不同在于，uid-generator支持自定义时间戳、工作机器ID和 序列号 等各部分的位数，而且uid-generator中采用用户自定义workId的生成策略。
uid-generator需要与数据库配合使用，需要新增一个WORKER_NODE表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的workId数据由host，port组成。
对于uid-generator ID组成结构：
workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，而且同一应用每次重启就会消费一个workId。
参考文献
https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md

美团（Leaf）
Leaf由美团开发，github地址：https://github.com/Meituan-Dianping/Leaf



----------------------------------  设计模式 ----------------------------------

工厂模式

代理模式

懒加载的两种实现

方法模板

充血枚举

状态机模式

适配器模式