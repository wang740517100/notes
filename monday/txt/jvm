1、什么是GC，为什么要有GC。

GC是垃圾收集的意思，防止内存泄露。

2、Java堆内存结构，Java堆的结构是什么样子的，简述下Java垃圾回收机制，简述Minor GC 和 Major GC。

新生代、老年代    1:2

永久代：jdk7，存在堆中
元空间：jdk8，存在内存中

新生代：伊甸区、幸存者1区（from区）和幸存者2区（to区）   8:1:1

Full GC 是清理整个堆空间—包括年轻代和永久代
Minor GC/轻GC/Young GC  新生代内存不足会触发
Major GC/重GC/Old GC  老年代GC  触发时机: 1)Minor GC前老年代内存空间<新生代历次gc后升入老年代的对象总和的平均大小, 2)Minor GC后老年代内存空间<新生代gc后升入老年代的对象, 3)使用率超过92%
Mixed GC G1中特有的, 一旦老年代占据堆内存的45%就要触发

在新生代里面的gc叫做 minor gc，一般使用复制算法。垃圾回收时，垃圾回收器将清理伊甸区和 from 区的对象，
然后将幸存的对象（可达性分析）放在 to 区，然后将 from 和 to 区切换，再次重复上面操作。当一个对象经
过15次清理后就会移到老年代里面。这种gc可以回收掉90%以上的对象，也被称为轻gc。

在老年代里面的gc叫做 major gc，一般使用标记整理算法。将幸存的对象整理到一起然后回收掉剩余空间的对象。
这种gc只能回收掉少部分对象，所以也被称为重gc。

新生代和老年代的垃圾回收算法合称为分代收集算法


3、堆内存结构。
.calss文件  ->  类加载器
堆 方法区    线程公共
虚拟机栈  本地方法栈   程序计数器      线程私有
执行引擎   本地方法库

-Xms: 堆内存的大小
-Xmx: 堆内存的最大大小
-Xmn: 堆内存新生代大小, 剩下的就是老年代。一般计算得到
-Xss: 每个线程的栈内存大小, 一般512KB-1MB
-XX:MetaspaceSize = 元空间大小,  一般几百MB
-XX:MaxMetaspaceSize = 元空间最大大小,  一般几百MB
(-XX:PermSize = 永久代大小  -XX:MaxPermSize = 永久代最大大小)

-XX:SurvivorRatio = 伊甸区占新生代的比例 8/10
-XX:MaxTenuringThreshold = 新生代对象gc次数阈值
-XX:PretenureSizeThreshold = 新生代对象大小阈值

-XX:+UseParNewGC  并行回收器
-XX:+UseConcMarkSweepGC CMS

-XX:+UseG1GC    G1  默认把堆分为2048个Region
-G1NewSizePercent G1设置新生代初始占比的, 默认是5%
-G1MaxNewSizePercent G1设置新生代最大占比的, 默认是60%
-XX:MaxGCPauseMills G1进行gc时"stop the world"的时间, 默认200ms,
    该参数会影响G1的策略(新生代达到临界值时是增加region还是进行gc), 尽量避免G1的混合回收

eg: 4核8G 堆给3G、新生代给2G内存, 老年代1.5G, 线程占内存1MB(共几百MB), 元空间256MB
-Xms4096M -Xmx4096M -Xmn:2048M -Xss1M -XX:MetaspaceSize=256M -XX:SurvivorRatio=8
-XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M
-XX:+UseParNewGC -XX:+UseConcMarkSweepGC

-Xms4096M -Xmx4096M -Xss1M -XX:MetaspaceSize=256M -XX:SurvivorRatio=8
-XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M
-XX:+UseG1GC

- 新生代每秒会产生几kb-1mb对象, 一个对象不到1kb左右, 一个小时左右发生一次minor gc
- 一般一个系统就几十M spring bean对象在老年代

案例: 新生代内存太小, 如果一批对象正在业务逻辑中时新生代已经发生了十几次Minor GC,
那么会有越来越多的对象进入老年代, 然后触发 Full GC 导致系统内存飙升而缓慢


3、如何判断一个对象是否存活。
可达性分析,可以作为 GC Roots 的对象。
1)虚拟机栈中引用的对象。
2)方法区中类静态属性引用的对象。
3)方法区中常量引用的对象。
4)本地方法栈中JNI引用的对象。

4、垃圾回收的优点和原理，并考虑2种回收机制。
1)不需要在编写程序的时候不需要考虑内存管理，因为有了垃圾回收机制；
2)垃圾回收机制可以有效的防治内存泄露，有效的使用可以使用的内存。
3)垃圾回收不可预知，不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。

复制算法：性能较好，浪费内存空间、不会产生内存碎片
标记清除算法：性能较好，会产生内存碎片。
标记整理算法：性能较差，不会产生内存碎片。

5、回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。
分代复制垃圾回收：见上
标记垃圾回收：见上

增量垃圾回收：上面的垃圾回收, 都需要暂停程序, 执行GC, 这就导致在GC执行期间, 程序得不到执行。
因此出现了增量式垃圾回收, 它并不会等GC执行完, 才将控制权交回程序, 而是一步一步执行, 跑一点, 
再跑一点, 逐步完成垃圾回收, 在程序运行中穿插进行. 极大地降低了GC的最大暂停时间.

在GC开始执行时, 所有对象都是白色的, 然后将根集合的对象放到栈中, 并标记为灰色, 依次处理。将对
象从栈中取出, 递归搜索所有子对象, 并标记为灰色, 当子对象搜索完后, 就将对象标记为黑色. 这样, 
当一个对象搜索完后, 该对象及其关联的所有子对象就都是黑色的了。当标记阶段结束后, 所有活动对象
都是黑色, 垃圾对象则是白色。此算法就是通过这样, 逐步对对象进行标记.

三色标记应用于标记清除中，标记清除算法在标记阶段, 应用三色标记逐步标记, 每次搜索一定次数后, 就
返回执行, 等待下次继续标记, 将标记分为小段穿插在程序中运行。在清除阶段, 也可以设置一个次数, 每
遍历一定数量的对象, 就返回等待下次继续。三色标记不光可以应用于标记清除中, 也可以应用于其他标记
算法中。

5、垃圾回收器的基本原理是什么，垃圾回收器可以马上回收内存吗，有什么办法主动通知虚拟机进行垃圾回收。
1)对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用
有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是
"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。
2)可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

6、System.gc() 和 Runtime.gc()会做些什么。
System.gc() 调用的是 Runtime.getRuntime().gc()
gc()函数的作用只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体
什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。

7、深拷贝和浅拷贝。
Object 的 clone() 方法
深拷贝会创建一个新的对象，浅拷贝拷贝的是引用地址。

8、如果对象的引用被置为null，垃圾回收器是否会立即释放对象占用的内存。
垃圾回调周期中，这个对象将是被可回收的。 也就是说并不会立即被垃圾收集器立刻回收，
而是在下一次垃圾回收时才会释放其占用的内存。

9、什么是分布式垃圾回收（DGC），它是如何工作的。
概念：
1)Java虚拟机中，一个远程对象不仅会被本地虚拟机内的变量引用，还会被远程引用。
2)只有当一个远程对象不受到任何本地引用和远程引用，这个远程对象才会结束生命周期。

说明：
1)服务端的一个远程对象在3个地方被引用：
	1>服务端的一个本地对象持有它的本地引用
	2>服务端的远程对象已经注册到rmiregistry注册表中，也就是说，rmiregistry注册表持有它的远程引用。
	3>客户端获得远程对象的存根对象，也就是说，客户端持有它的远程引用。
2)服务端判断客户端是否持有远程对象引用的方法：
	1>当客户端获得一个服务端的远程对象的存根时，就会向服务器发送一条租约(lease)通知，以告诉服务器自己持有了这个远程对象的引用了。
	2>客户端定期地向服务器发送租约通知，以保证服务器始终都知道客户端一直持有着远程对象的引用。
	3>租约是有期限的，如果租约到期了，服务器则认为客户端已经不再持有远程对象的引用了。

10、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么。
吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。
串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

11、在Java中，对象什么时候可以被垃圾回收。
当一个对象到GC Roots不可达时，在下一个垃圾回收周期中尝试回收该对象，如果该对象重写了finalize()方法，并在这个方法中成功自救(将自身赋予某个引用)，
那么这个对象不会被回收。但如果这个对象没有重写finalize()方法或者已经执行过这个方法，也自救失败，该对象将会被回收。

第一次标记该对象后都会将对象的finalnize()方法放到一个队列中，在垃圾回收时。以此调用finalnize()方法，如果重写了finalnize()使对象可达，便去除标记。
我是这么理解的，因为即使重写了finalnaize()而并没有使对象可达的化一样会被回收的。

12、JVM的永久代中会发生垃圾回收吗。
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被
回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。

13、Java中垃圾收集的方法有哪些。
引用计数算法（Reference Counting）
介绍：给对象添加一个引用计数器，每当一个地方引用它时，数据器加1；当引用失效时，计数器减1；计数器为0的即可被回收。
优点：实现简单，判断效率高
缺点：很难解决对象之间的相互循环引用（objA.instance = objB; objB.instance = objA）的问题，所以java语言并没有选用引用计数法管理内存

根搜索算法
标记-清除算法
复制算法
标记整理算法
分代收集算法
(见上)

14、什么是堆中的永久代（Perm Gen space）。
永久代是用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，
在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含：
	类的方法(字节码...)
	类名(Sring对象)
	.class文件读到的常量信息
	class对象相关的对象列表和类型列表 (e.g., 方法对象的array).
	JVM创建的内部对象
	JIT编译器优化用的信息
持久代大小通过-XX:MaxPermSize=<N>进行设置

JDK1.8中，永久代已经从java堆中移除，String直接存放在堆中，类的元数据存储在meta space中，meta space占用外部内存，不占用堆

15、简述各个版本内存区域的变化。
jdk7 永久代
jdk8 元空间

16、说说各个区域的作用。
方法区：堆放类信息如静态方法、变量。
堆：存放对象，垃圾回收的地方。
本地方法栈：执行第三方语言库的地方，如调c++的native方法。
虚拟机栈：执行方法的地方，存放变量的信息等。
执行引擎：执行字节码文件的地方。

17、Java中存在内存泄漏吗，简述一下。
存在，ThreadLocal在使用后不clear就会内存泄漏。
1)内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
2)内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型
   的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。

18、Java类加载过程，描述下JVM加载Class文件的原理机制，什么是类加载。
类加载的入口是main(), 当方法里用到哪个类时就会加载哪个类
1)加载：通过全限定名获取二进制流，然后加载进方法区。
2)验证：文件格式验证(魔数、版本号等)、父类相关信息(是否可继承等)、程序语义是否合法、符号引用是否正确(是否能找到引用的类、方法、字段和修饰词是否可以被访问)。
3)准备：在方法区给类变量(静态变量)分配内存并设置默认值
4)解析：将符号引用转换为直接引用(句柄、指针)。
5)初始化：在堆里面初始化对象。


19、类加载器有哪些，类加载器双亲委派模型机制。
启动类加载器  Bootstrap ClassLoader 加载存放于<JAVA_HOME>\lib目录中的
拓展类加载器  Extension ClassLoader 加载<JAVA_HOME>\lib\ext目录下的
应用类加载器  Application ClassLoader 负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用

双亲委派模型机制：当执行类加载动作时，当前类加载器会把请求交给父类加载器去加载，直到父类加载器无法完成加载时才会让子加载器去加载。

双亲委派模型机制四次被破坏: https://blog.csdn.net/weixin_40682142/article/details/106265178

20、什么是tomcat类加载机制。
Tomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)
会优先加载，加载不到时再交给commonClassLoader走双亲委托。 

https://www.cnblogs.com/aspirant/p/8991830.html

21、讲讲你理解的性能评价及测试指标。
对于Web应用一般重点关注的性能指标主要是吞吐量、响应时间、QPS、TPS等、并发用户数等。
系统资源一般指如CPU、内存、磁盘IO、网络IO等资源。
以下说明以Linux为例，性能测试中，主要观察的cpu、内存、磁盘等指标的信息。

https://blog.csdn.net/lijingyao8206/article/details/80325670

22、什么是GC调优，常用的性能优化方式有哪些。
当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化。但GC算法复杂，
影响GC性能的参数众多，且参数调整又依赖于应用各自的特点，这些因素很大程度上增加了GC优化的难度。

常用的性能优化方式：
1）代码
2）SQL调优
3）架构层面的调优：读写分离、多从库负载均衡、水平和垂直分库分表
4）连接池调优
5）缓存：本地缓存（HashMap/ConcurrentHashMap、Ehcache、Guava Cache等），缓存服务（Redis/Tair/Memcache等）
6）异步：改同步为异步
7）NoSQL：如es
8）JVM调优：
设置堆大小初始化大小和最大内存大小一致，防止内存迭代带来的抖动。
（1）如果发现高峰期CPU使用率与Load值偏大，这个时候可以观察一些JVM的thread count以及gc count（可能主要是young gc count），如果这两个值都比以往偏大
	（也可以和一个历史经验值作对比），基本上可以定位是young gc频率过高导致，这个时候可以通过适当增大young区大小或者占比的方式来解决。
（2）如果发现关键接口响应时间很慢，可以结合gc time以及gc log中的stop the world的时间，看一下整个应用的stop the world的时间是不是比较多。如果是，可
	能需要减少总的gc time，具体可以从减小gc的次数和减小单次gc的时间这两个维度来考虑，一般来说，这两个因素是一对互斥因素，我们需要根据实际的监控数据
	来调整相应的参数（比如新生代与老生代比值、eden与survivor比值、MTT值、触发cms回收的old区比率阈值等）来达到一个最优值。
（3）如果发生full gc或者old cms gc非常频繁，通常这种情况会诱发STW的时间相应加长，从而也会导致接口响应时间变慢。这种情况，大概率是出现了“内存泄露”，
	Java里的内存泄露指的是一些应该释放的对象没有被释放掉（还有引用拉着它）。那么这些对象是如何产生的呢？为啥不会释放呢？对应的代码是不是出问题了？
	问题的关键是搞明白这个，找到相应的代码，然后对症下药。所以问题的关键是转化成寻找这些对象。怎么找？综合使用jmap和MAT，基本就能定位到具体的代码


23、四种引用
new(强引用): 永远不会被回收
SoftReference(软引用): 内存足够时不会被GC回收, 内存不足时会被回收
WeakReference(弱引用): 会被GC回收
PhantomRefrence(虚引用): 在任何时候都可能被垃圾回收器回收, 跟踪对象被垃圾回收的状态, 钩子函数finalize()


24、WeakHashMap
首先GC每次清理掉一个对象之后，引用对象会被放到ReferenceQueue中。然后遍历这个queue进行删除即可
https://blog.csdn.net/Jack_PJ/article/details/88016471

25、线上GC问题监控
jps -v  查看java进程的pid
jstat -gc pid  查看java进程的内存和gc
S0C: from区的大小
S1C: to区的大小
S0U：from区当前使用的内存大小
S1U：to区当前使用的内存大小
EC:  eden区的大小
EU:  eden区老年代老年代
OC:  老年代的大小
OU:  老年代老年代
MC:  方法区(永久代、元空间)的大小
MU:  方法区(永久代、元空间)当前使用的内存大小
YGC: 系统运行迄今为止的Young GC次数
YGCT:Young GC的耗时
FGC: 系统运行迄今为止的Full GC次数
FGCT:Full GC的耗时
GCT: 所有GC的耗时

jstat -gc pid 1000 10  每隔1s更新出来最新的一行统计信息共执行10次

jmap -histo pid  打印各种对象占用内存空间的大小降序排列, 快速定位哪个对象占用内存
jmap -dump:live,format=b,file=dump.hprof pid 生成快照使用MermoryAnalyzer

jmap -heap pid 打印堆内存信息, 还没jstat信息全一般不用
jhat dump.hprof -port 7000  启动jhat服务器分析dump快照, 在浏览器访问这台机器的7000端口号就可以了









